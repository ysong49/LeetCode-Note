## 146. LRU Cache [H]
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: `get` and `set`.

`get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.   
`set(key, value)` - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.   

## Code:
- Solution 1 - find key in the list (Time Limit Exceeded):
```c++
class LRUCache
{
    // date: 2016-08-01     location: Santa Clara City Library
    unordered_map<int, pair<int, list<int>::iterator>> values;
    list<int> order;
    int capacity;
    
public:
    LRUCache(int _capacity) 
    {
        capacity = _capacity;
    }
    
    int get(int key) 
    { 
        list<int>::iterator it = find(order.begin(), order.end(), key);
        if (it != order.end())
        {
            order.erase(it);
            order.push_front(key);
            values[key].second = order.begin();
            return values[key].first;
        }
        return -1;
    }
    
    void set(int key, int value) 
    {
        list<int>::iterator it = find(order.begin(), order.end(), key);
        if (it != order.end()) // found
        {
            order.erase(it);
            order.push_front(key);
            values[key].first = value;
            values[key].second = order.begin();
        }
        else
        {
            order.push_front(key); // not found
            if (order.size() > capacity)
            {
                values.erase(order.back());
                order.pop_back();
            }
            values[key] = make_pair(value, order.begin());
        }
    }
 };
 ```
 
 - Solution 2 - find keys in the map and locate the timestamp with the iterator in the map (90 ms):
 ```c++
 
 ```
