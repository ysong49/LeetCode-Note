## 98. Validate Binary Search Tree [M]
Given a binary tree, determine if it is a valid binary search tree (BST).   

Assume a BST is defined as follows:   

- The left subtree of a node contains only nodes with keys **less than** the node's key.   
- The right subtree of a node contains only nodes with keys **greater than** the node's key.   
- Both the left and right subtrees must also be binary search trees.   

#### Example 1:
```
    2
   / \
  1   3
```
Binary tree `[2,1,3]`, return true.

####Example 2:
```
    1
   / \
  2   3
```
Binary tree `[1,2,3]`, return false.


## Code:
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
    // date: 2016-08-17     location: Santa Clara City Library
public:
    bool isValidBST(TreeNode* root) 
    {
        if (!root)  return true;
        // Edge cases include [INT_MAX], if the prgram does not check the left pointer.
        // leftMax(root -> left) will return INT_MAX, which leads to a false return value.
        if ((root -> left && leftMax(root -> left) >= root -> val) 
            || (root -> right && rightMin(root -> right) <= root -> val))
            return false;
        
        return isValidBST(root -> left) && isValidBST(root -> right);
    }
    
    int leftMax(TreeNode* node)
    {
        if (!node) return INT_MIN;
        return max(node -> val, max(leftMax(node -> left), leftMax(node -> right)));
    }    
    
    int rightMin(TreeNode* node)
    {
        if (!node) return INT_MAX;
        return min(node -> val, min(rightMin(node -> left), rightMin(node -> right)));
    }
};
```
