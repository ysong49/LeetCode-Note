## 98. Validate Binary Search Tree [M]
Given a binary tree, determine if it is a valid binary search tree (BST).   

Assume a BST is defined as follows:   

- The left subtree of a node contains only nodes with keys **less than** the node's key.   
- The right subtree of a node contains only nodes with keys **greater than** the node's key.   
- Both the left and right subtrees must also be binary search trees.   

#### Example 1:
```
    2
   / \
  1   3
```
Binary tree `[2,1,3]`, return true.

####Example 2:
```
    1
   / \
  2   3
```
Binary tree `[1,2,3]`, return false.


## Code:
- Solution 1 - leftMax & rightMin (24 ms):
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
    // date: 2016-08-17     location: Santa Clara City Library
public:
    bool isValidBST(TreeNode* root) 
    {
        if (!root)  return true;
        // Edge cases include [INT_MAX], if the prgram does not check the left pointer.
        // leftMax(root -> left) will return INT_MAX, which leads to a false return value.
        if ((root -> left && leftMax(root -> left) >= root -> val) 
            || (root -> right && rightMin(root -> right) <= root -> val))
            return false;
        
        return isValidBST(root -> left) && isValidBST(root -> right);
    }
    
    int leftMax(TreeNode* node)
    {
        if (!node) return INT_MIN;
        return max(node -> val, max(leftMax(node -> left), leftMax(node -> right)));
    }    
    
    int rightMin(TreeNode* node)
    {
        if (!node) return INT_MAX;
        return min(node -> val, min(rightMin(node -> left), rightMin(node -> right)));
    }
};
```

- Solution 2 - in-order traversal (16 ms):
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
    // date: 2016-08-17     location: Santa Clara City Library
public:
    bool isValidBST(TreeNode* root) 
    {
        if (!root)  return true;
        vector<int> nums;
        helper(nums, root);
        for (int i = 0; i < nums.size() - 1; i ++)
            if (nums[i] >= nums[i + 1])
                return false;
        return true;
    }
    
    void helper(vector<int>& nums, TreeNode* node)
    {
        if (!node)  return;
        helper(nums, node -> left);
        nums.push_back(node -> val);
        helper(nums, node -> right);
    }
};
```

- Solution 3 - in-order traversal 2.0 without vector (16 ms):
```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution 
{
    // date: 2016-08-17     location: Santa Clara City Library
public:
    bool isValidBST(TreeNode* root) 
    {
        TreeNode* prev = NULL;
        return helper(root, prev);
    }
    
    bool helper(TreeNode* node, TreeNode* &prev)
    {
        if (!node)      return true;
        if (!helper(node -> left, prev))    return false;
        if (prev && prev -> val >= node -> val)
            return false;
        prev = node;
        return helper(node -> right, prev);
    }
};
```
